/*
 *	server/zone/objects/creature/action/ActionCreature.cpp generated by engine3 IDL compiler 0.55
 */

#include "ActionCreature.h"

#include "ActionCreatureImplementation.h"

#include "Action.h"

#include "../../../managers/mission/MissionManagerImplementation.h"

#include "../../scene/SceneObject.h"

#include "../../player/Player.h"

#include "../Creature.h"

/*
 *	ActionCreatureStub
 */

ActionCreature::ActionCreature(unsigned long long oid, unsigned int objCrc, String& creName, String& stf, String& missionKey) : Creature(DummyConstructorParameter::instance()) {
	_impl = new ActionCreatureImplementation(oid, objCrc, creName, stf, missionKey);
	_impl->_setStub(this);
}

ActionCreature::ActionCreature(DummyConstructorParameter* param) : Creature(param) {
}

ActionCreature::~ActionCreature() {
}

void ActionCreature::addAction(String& key, Action* act) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 6);
		method.addAsciiParameter(key);
		method.addObjectParameter(act);

		method.executeWithVoidReturn();
	} else
		((ActionCreatureImplementation*) _impl)->addAction(key, act);
}

Action* ActionCreature::getAction(String& key) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 7);
		method.addAsciiParameter(key);

		return (Action*) method.executeWithObjectReturn();
	} else
		return ((ActionCreatureImplementation*) _impl)->getAction(key);
}

void ActionCreature::onConverse(String& tco, Player* player) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 8);
		method.addAsciiParameter(tco);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else
		((ActionCreatureImplementation*) _impl)->onConverse(tco, player);
}

void ActionCreature::onTrade(String& ttr) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 9);
		method.addAsciiParameter(ttr);

		method.executeWithVoidReturn();
	} else
		((ActionCreatureImplementation*) _impl)->onTrade(ttr);
}

void ActionCreature::onAttack(String& tat) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 10);
		method.addAsciiParameter(tat);

		method.executeWithVoidReturn();
	} else
		((ActionCreatureImplementation*) _impl)->onAttack(tat);
}

void ActionCreature::onDeath(String& tde) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 11);
		method.addAsciiParameter(tde);

		method.executeWithVoidReturn();
	} else
		((ActionCreatureImplementation*) _impl)->onDeath(tde);
}

bool ActionCreature::isMissionNpc() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 12);

		return method.executeWithBooleanReturn();
	} else
		return ((ActionCreatureImplementation*) _impl)->isMissionNpc();
}

String& ActionCreature::getMissionKey() {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 13);

		method.executeWithAsciiReturn(_return_getMissionKey);
		return _return_getMissionKey;
	} else
		return ((ActionCreatureImplementation*) _impl)->getMissionKey();
}

MissionManagerImplementation* ActionCreature::getMisoMgr() {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		return ((ActionCreatureImplementation*) _impl)->getMisoMgr();
}

void ActionCreature::setMisoMgr(MissionManagerImplementation* tmgr) {
	if (_impl == NULL) {
		throw ObjectNotLocalException(this);

	} else
		((ActionCreatureImplementation*) _impl)->setMisoMgr(tmgr);
}

void ActionCreature::sendConversationStartTo(SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 14);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((ActionCreatureImplementation*) _impl)->sendConversationStartTo(obj);
}

void ActionCreature::selectConversationOption(int option, SceneObject* obj) {
	if (_impl == NULL) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, 15);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else
		((ActionCreatureImplementation*) _impl)->selectConversationOption(option, obj);
}

/*
 *	ActionCreatureAdapter
 */

ActionCreatureAdapter::ActionCreatureAdapter(ActionCreatureImplementation* obj) : CreatureAdapter(obj) {
}

Packet* ActionCreatureAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	Packet* resp = new MethodReturnMessage(0);

	switch (methid) {
	case 6:
		addAction(inv->getAsciiParameter(_param0_addAction__String_Action_), (Action*) inv->getObjectParameter());
		break;
	case 7:
		resp->insertLong(getAction(inv->getAsciiParameter(_param0_getAction__String_))->_getObjectID());
		break;
	case 8:
		onConverse(inv->getAsciiParameter(_param0_onConverse__String_Player_), (Player*) inv->getObjectParameter());
		break;
	case 9:
		onTrade(inv->getAsciiParameter(_param0_onTrade__String_));
		break;
	case 10:
		onAttack(inv->getAsciiParameter(_param0_onAttack__String_));
		break;
	case 11:
		onDeath(inv->getAsciiParameter(_param0_onDeath__String_));
		break;
	case 12:
		resp->insertBoolean(isMissionNpc());
		break;
	case 13:
		resp->insertAscii(getMissionKey());
		break;
	case 14:
		sendConversationStartTo((SceneObject*) inv->getObjectParameter());
		break;
	case 15:
		selectConversationOption(inv->getSignedIntParameter(), (SceneObject*) inv->getObjectParameter());
		break;
	default:
		return NULL;
	}

	return resp;
}

void ActionCreatureAdapter::addAction(String& key, Action* act) {
	return ((ActionCreatureImplementation*) impl)->addAction(key, act);
}

Action* ActionCreatureAdapter::getAction(String& key) {
	return ((ActionCreatureImplementation*) impl)->getAction(key);
}

void ActionCreatureAdapter::onConverse(String& tco, Player* player) {
	return ((ActionCreatureImplementation*) impl)->onConverse(tco, player);
}

void ActionCreatureAdapter::onTrade(String& ttr) {
	return ((ActionCreatureImplementation*) impl)->onTrade(ttr);
}

void ActionCreatureAdapter::onAttack(String& tat) {
	return ((ActionCreatureImplementation*) impl)->onAttack(tat);
}

void ActionCreatureAdapter::onDeath(String& tde) {
	return ((ActionCreatureImplementation*) impl)->onDeath(tde);
}

bool ActionCreatureAdapter::isMissionNpc() {
	return ((ActionCreatureImplementation*) impl)->isMissionNpc();
}

String& ActionCreatureAdapter::getMissionKey() {
	return ((ActionCreatureImplementation*) impl)->getMissionKey();
}

void ActionCreatureAdapter::sendConversationStartTo(SceneObject* obj) {
	return ((ActionCreatureImplementation*) impl)->sendConversationStartTo(obj);
}

void ActionCreatureAdapter::selectConversationOption(int option, SceneObject* obj) {
	return ((ActionCreatureImplementation*) impl)->selectConversationOption(option, obj);
}

/*
 *	ActionCreatureHelper
 */

ActionCreatureHelper* ActionCreatureHelper::staticInitializer = ActionCreatureHelper::instance();

ActionCreatureHelper::ActionCreatureHelper() {
	className = "ActionCreature";

	DistributedObjectBroker::instance()->registerClass(className, this);
}

void ActionCreatureHelper::finalizeHelper() {
	ActionCreatureHelper::finalize();
}

DistributedObject* ActionCreatureHelper::instantiateObject() {
	return new ActionCreature(DummyConstructorParameter::instance());
}

DistributedObjectAdapter* ActionCreatureHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ActionCreatureAdapter((ActionCreatureImplementation*) obj->_getImplementation());

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	ActionCreatureServant
 */

ActionCreatureServant::ActionCreatureServant(unsigned long long oid) : CreatureImplementation(oid) {
	_classHelper = ActionCreatureHelper::instance();
}

ActionCreatureServant::~ActionCreatureServant() {
}

void ActionCreatureServant::_setStub(DistributedObjectStub* stub) {
	_this = (ActionCreature*) stub;
	CreatureServant::_setStub(stub);
}

DistributedObjectStub* ActionCreatureServant::_getStub() {
	return _this;
}

